<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Photo Bridge LAN — LAN-only Mode</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600&family=Uncial+Antiqua&display=swap" rel="stylesheet">
  <style>
    :root{ --bg:#071612; --panel:#123624; --accent:#9edc7a; --text:#eaf5e8 }
    body{ margin:0; font-family:'Uncial Antiqua', serif; background:linear-gradient(180deg,#071612,#05120f); color:var(--text); min-height:100vh; display:flex; flex-direction:column; align-items:center; gap:12px; }
    header{ padding:18px; font-family:'Cinzel',serif; font-size:1.6rem; color:var(--accent) }
    .bar{ width:min(1100px,95%); display:flex; gap:8px; align-items:center; justify-content:space-between}
    .panel{ width:min(1100px,95%); background:linear-gradient(145deg,#0e3b25,#0a2e1b); border:2px solid var(--accent); border-radius:10px; padding:12px; box-shadow:0 4px 12px rgba(0,0,0,0.6) }
    .device-card{ display:block; padding:8px 12px; margin:6px 0; background:transparent; border:1px solid rgba(255,255,255,0.03); color:var(--text); border-radius:6px; cursor:pointer; text-align:left }
    .device-card:hover{ filter:brightness(1.05) }
    #gallery img{ max-width:200px; border:3px solid var(--accent); border-radius:6px; margin:8px }
    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .hint{ opacity:.85; font-size:.92rem }
    progress{ width:160px; height:12px; }
    .pill{ padding:8px 10px; border-radius:8px; background:linear-gradient(145deg,#114b32,#0b3a26); border:1px solid var(--accent); color:var(--text); cursor:pointer }
    #log{ font-family:monospace; font-size:12px; max-height:140px; overflow:auto; background:rgba(0,0,0,0.2); padding:8px; border-radius:6px }
  </style>
</head>
<body>
  <header>Photo Bridge LAN — <strong>LAN-only</strong> mode (same Wi-Fi / hotspot required)</header>

  <div class="bar" style="width:min(1100px,95%);">
    <div class="hint" id="status">초기화 대기…</div>
    <div class="row">
      <button id="refreshBtn" class="pill">새로고침</button>
      <button id="leaveBtn" class="pill" disabled>나가기</button>
    </div>
  </div>

  <div class="panel">
    <h3>근처 기기</h3>
    <div id="deviceList">검색 중…</div>
  </div>

  <div class="panel">
    <h3>파일 전송</h3>
    <div class="row">
      <label class="pill" style="cursor:pointer">
        파일 선택 <input id="fileInput" type="file" style="display:none" />
      </label>
      <button id="sendBtn" class="pill" disabled>전송</button>
      <button id="clearBtn" class="pill">대기열 비우기</button>
      <button id="speedTestBtn" class="pill">속도테스트(5MB)</button>
    </div>
    <div id="queue" style="margin-top:10px"></div>
  </div>

  <div class="panel">
    <h3>받은 파일 / 미리보기</h3>
    <div id="gallery"></div>
  </div>

  <div class="panel" style="width:min(1100px,95%);">
    <h3>디버그 로그</h3>
    <div id="log"></div>
  </div>

  <!-- Socket.IO loader: try local then CDN -->
  <script>
    window.__ioReady = (async function(){
      const hasIo = ()=> typeof window.io === 'function' || typeof window.io === 'object';
      function load(src){
        return new Promise(res=>{
          const s=document.createElement('script');
          s.src=src; s.async=true; s.crossOrigin='anonymous';
          s.onload=()=>res(true); s.onerror=()=>res(false); document.head.appendChild(s);
        });
      }
      if(hasIo()) return true;
      let ok = await load('/socket.io/socket.io.js'); if(hasIo()) return true;
      if(!ok) ok = await load('https://cdn.socket.io/4.7.5/socket.io.min.js');
      return hasIo();
    })();
  </script>

  <script>
  (async function(){
    // wait socket.io
    await (window.__ioReady || Promise.resolve(false));

    // small logger
    const $ = s => document.querySelector(s);
    const logEl = $('#log');
    function log(...args){ console.log(...args); if(logEl) logEl.innerText += args.map(a=> (typeof a==='string'?a:JSON.stringify(a))).join(' ') + '\n'; logEl.scrollTop = 1e9; }

    const statusEl = $('#status'), deviceListEl = $('#deviceList'), queueEl = $('#queue'), galleryEl = $('#gallery');
    const fileInput = $('#fileInput'), sendBtn = $('#sendBtn'), clearBtn = $('#clearBtn'), refreshBtn = $('#refreshBtn');
    const leaveBtn = $('#leaveBtn'), speedTestBtn = $('#speedTestBtn');

    // Networking / transport tuning
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    let MAX_CHUNK = isSafari ? 64*1024 : 256*1024; // initial suggestion; may be tuned
    let LOW_WATER = 2 * 1024 * 1024; // bufferedAmountLowThreshold

    const myName = `Device-${Math.floor(Math.random()*9000)+1000}-${Date.now()}`;
    let socket = null, peer = null, channel = null, role = null, currentRoom = null;
    const queue = [];

    function setStatus(s){ if(statusEl) statusEl.textContent = s; log('[STATUS]', s); }

    // =========== Signaling (simple) ===========
    function initSocket(){
      if(!window.io){ setStatus('Socket.IO 클라이언트 없음'); return; }
      socket = io({ transports:['websocket','polling'] });

      socket.on('connect', ()=>{ setStatus(`신호 연결됨 — ${myName}`); socket.emit('announce', myName); });
      socket.on('deviceList', list=>{
        deviceListEl.innerHTML = '';
        const others = list.filter(x=> x.name !== myName);
        if(!others.length){ deviceListEl.innerHTML = '<div class="hint">주변 탐험가 없음</div>'; return; }
        others.forEach(d=>{
          const btn = document.createElement('button');
          btn.className = 'device-card';
          btn.textContent = d.name;
          btn.onclick = ()=> socket.emit('request', { from: myName, to: d.name });
          deviceListEl.appendChild(btn);
        });
      });

      socket.on('request', ({from})=>{
        if(confirm(`${from}에서 연결 요청`)) socket.emit('accept',{ from: myName, to: from });
      });

      // pair: server assigns room + roles
      socket.on('pair', ({roomId, role: r})=>{
        log('[SIGNAL] pair', roomId, r);
        currentRoom = roomId; role = r;
        socket.emit('join', roomId);
        initPeer().then(()=>{ if(role === 'offerer') makeOffer(); });
      });

      // offer/answer exchanged as-is
      socket.on('offer', async (offer) => {
        log('[SIGNAL] offer received');
        await peer.setRemoteDescription(offer);
        const answer = await peer.createAnswer();
        await peer.setLocalDescription(answer);
        socket.emit('answer', { roomId: currentRoom, answer });
      });
      socket.on('answer', async (answer) => {
        log('[SIGNAL] answer received');
        await peer.setRemoteDescription(answer);
      });

      // candidate messages: server forwards { roomId, candidate }
      socket.on('candidate', async ({ candidate }) => {
        if(!candidate) return;
        const s = candidate.candidate || '';
        // **LAN-only accept**: only add host candidates
        if(s.includes(' typ host ') || s.includes(' typ host')){
          try { await peer.addIceCandidate(new RTCIceCandidate(candidate)); log('[ICE] host candidate added'); }
          catch(e){ log('[ICE] add error', e); }
        } else {
          log('[ICE] ignored non-host candidate');
        }
      });

      refreshBtn.onclick = ()=> socket.emit('announce', myName);
    }

    // =========== Peer setup (LAN-only) ===========
    async function initPeer(){
      if(peer) try{ peer.close(); }catch(e){}

      // IMPORTANT: no STUN/TURN -> only host candidates (if available)
      peer = new RTCPeerConnection({
        iceServers: [],   // empty prevents srflx/relay generation
        sdpSemantics: 'unified-plan'
      });

      peer.onicecandidate = (e) => {
        if(!e.candidate || !e.candidate.candidate) return;
        const s = e.candidate.candidate;
        // forward only host candidates
        if(s.includes(' typ host ') || s.includes(' typ host')){
          socket.emit('candidate', { roomId: currentRoom, candidate: e.candidate });
          log('[ICE] forwarded host candidate');
        } else {
          log('[ICE] skipped non-host candidate (not forwarded)');
        }
      };

      peer.onconnectionstatechange = ()=> {
        setStatus('P2P 상태: ' + peer.connectionState);
        leaveBtn.disabled = !['disconnected','failed','closed'].includes(peer.connectionState);
      };

      // optional: inspect candidate-pair stats when connected
      peer.oniceconnectionstatechange = async ()=>{
        log('[ICE] state', peer.iceConnectionState);
        if(peer.iceConnectionState === 'connected' || peer.iceConnectionState === 'completed'){
          try{
            const stats = await peer.getStats();
            stats.forEach(r=>{
              if(r.type === 'candidate-pair' && r.state === 'succeeded' && r.selected){
                log('[STATS] selected candidate-pair', r);
              }
            });
          }catch(e){ log('[STATS] getStats error', e); }
        }
      };

      if(role === 'offerer'){
        channel = peer.createDataChannel('fileChannel', { ordered: true });
        setupChannel(channel);
      } else {
        peer.ondatachannel = (ev) => { channel = ev.channel; setupChannel(channel); };
      }
    }

    async function makeOffer(){
      const offer = await peer.createOffer({ offerToReceiveAudio:false, offerToReceiveVideo:false });
      await peer.setLocalDescription(offer);
      socket.emit('offer', { roomId: currentRoom, offer });
      log('[SIGNAL] sent offer');
    }

    function setupChannel(ch){
      channel = ch;
      channel.binaryType = 'arraybuffer';

      // tune thresholds after open
      channel.onopen = async () => {
        try{
          // try to derive reasonable chunk size from SCTP if available
          const sctp = peer.sctp;
          if(sctp && sctp.maxMessageSize){
            MAX_CHUNK = Math.min(sctp.maxMessageSize, isSafari ? 128*1024 : 256*1024);
            log('[CHANNEL] maxMessageSize', sctp.maxMessageSize, '-> MAX_CHUNK', MAX_CHUNK);
          } else {
            log('[CHANNEL] sctp not available, using MAX_CHUNK', MAX_CHUNK);
          }
        }catch(e){ log('[CHANNEL] tuning error', e); }
        // allow larger in-flight bytes
        try{ channel.bufferedAmountLowThreshold = LOW_WATER; }catch(e){}
        setStatus('데이터채널 열림');
        sendBtn.disabled = queue.length === 0;
      };

      channel.onclose = ()=> setStatus('데이터채널 닫힘');
      channel.onerror = (e)=> log('[CHANNEL] error', e);
      channel.onmessage = onData;
    }

    // =========== Protocol: control frames (text) + binary chunks ===========
    // control messages are small JSON strings; binary messages are chunk ArrayBuffers
    let rxCtx = null;

    async function onData(e){
      if(typeof e.data === 'string'){
        const msg = JSON.parse(e.data);
        if(msg.t === 'hello'){ channel.send(JSON.stringify({ t:'ack' })); return; }
        if(msg.t === 'file'){
          rxCtx = { name: msg.name, size: msg.size, type: msg.type || 'application/octet-stream', lastModified: msg.lastModified || Date.now(), parts: [], received: 0, hash: msg.hash };
          setStatus(`수신 시작: ${msg.name} (${(msg.size/1024/1024).toFixed(2)} MB)`);
          return;
        }
        if(msg.t === 'eof'){
          const blob = new Blob(rxCtx.parts, { type: rxCtx.type });
          if(blob.size !== rxCtx.size){ log('size mismatch'); channel.send(JSON.stringify({ t:'err', why:'size_mismatch' })); rxCtx = null; return; }
          if(rxCtx.hash){
            const buf = await blob.arrayBuffer(); const digest = await crypto.subtle.digest('SHA-256', buf);
            // hex
            const hex = [...new Uint8Array(digest)].map(b=>b.toString(16).padStart(2,'0')).join('');
            if(hex !== rxCtx.hash){ log('hash mismatch'); channel.send(JSON.stringify({ t:'err', why:'hash_mismatch' })); rxCtx = null; return; }
          }
          const f = new File([blob], rxCtx.name, { type: rxCtx.type, lastModified: rxCtx.lastModified });
          showPreview(f);
          setStatus(`수신 완료: ${rxCtx.name}`);
          channel.send(JSON.stringify({ t:'ack' }));
          rxCtx = null;
          return;
        }
        if(msg.t === 'err'){ log('peer err', msg.why); setStatus('상대 오류: ' + msg.why); return; }
        return;
      }

      // binary chunk (maybe bench or file chunk)
      if(rxCtx && rxCtx.bench){
        rxCtx.bytes += e.data.byteLength;
        return;
      }
      if(rxCtx){ rxCtx.parts.push(e.data); rxCtx.received += e.data.byteLength; }
    }

    // =========== send pipeline ===========
    async function sendQueue(){
      if(!channel || channel.readyState !== 'open'){ alert('데이터채널 준비되지 않음'); return; }
      sendBtn.disabled = true;
      for(const item of queue){ try{ await sendOne(item); }catch(e){ log('send error', e); } }
      clearQueue();
    }

    async function sendOne({ id, file }){
      const pg = document.getElementById(`pg-${id}`);
      const st = document.getElementById(`st-${id}`);
      st.textContent = '해시 계산 중…';
      const buf = await file.arrayBuffer();
      const hashBuf = await crypto.subtle.digest('SHA-256', buf);
      const hashHex = [...new Uint8Array(hashBuf)].map(b=>b.toString(16).padStart(2,'0')).join('');

      st.textContent = '전송 시작…';
      channel.send(JSON.stringify({ t:'file', name: file.name, size: file.size, type: file.type, lastModified: file.lastModified, hash: hashHex }));
      await new Promise(r=>setTimeout(r, 10));

      const view = new Uint8Array(buf);
      let sent = 0;
      while(sent < view.length){
        const chunk = view.subarray(sent, Math.min(sent + MAX_CHUNK, view.length));
        // backpressure
        if(channel.bufferedAmount > channel.bufferedAmountLowThreshold){
          await new Promise(res=>{
            const onLow = ()=>{ channel.removeEventListener('bufferedamountlow', onLow); res(); };
            channel.addEventListener('bufferedamountlow', onLow, { once:true });
          });
        }
        channel.send(chunk);
        sent += chunk.length;
        if(pg) pg.value = Math.round((sent / view.length) * 100);
        if(st) st.textContent = `${(sent/1024/1024).toFixed(2)} MB / ${(view.length/1024/1024).toFixed(2)} MB`;
      }
      channel.send(JSON.stringify({ t:'eof' }));

      // wait for ack
      await new Promise((resolve, reject) => {
        const timer = setTimeout(()=>reject(new Error('ACK timeout')), 15000);
        const onMsg = (ev) => {
          if(typeof ev.data === 'string'){
            try{ const m = JSON.parse(ev.data); if(m.t === 'ack'){ clearTimeout(timer); channel.removeEventListener('message', onMsg); st.textContent = '완료'; resolve(); } }catch(e){}
          }
        };
        channel.addEventListener('message', onMsg);
      }).catch(err=>{ st.textContent = '에러'; channel.send(JSON.stringify({ t:'err', why: err.message })); });
    }

    // =========== UI helpers ===========
    function addToQueue(file){
      const id = `${file.name}-${file.size}-${file.lastModified}-${Math.random().toString(36).slice(2,8)}`;
      const row = document.createElement('div'); row.className='row'; row.id = `row-${id}`;
      row.innerHTML = `<div style="min-width:240px">${file.name} <small style="opacity:.7">(${(file.size/1024/1024).toFixed(2)}MB)</small></div>
        <progress id="pg-${id}" max="100" value="0"></progress>
        <div id="st-${id}" class="hint" style="width:180px">대기</div>`;
      queueEl.appendChild(row);
      queue.push({ id, file, row });
      sendBtn.disabled = !channel || channel.readyState !== 'open' ? true : false;
    }
    function clearQueue(){ queue.length = 0; queueEl.innerHTML = ''; sendBtn.disabled = true; }
    function showPreview(file){
      if(file.type.startsWith('image/')){ const u = URL.createObjectURL(file); const img = new Image(); img.src = u; img.onload=()=>URL.revokeObjectURL(u); galleryEl.prepend(img); }
      else { const a = document.createElement('a'); a.className='hint'; a.download = file.name; a.href = URL.createObjectURL(file); a.textContent = `⬇ ${file.name}`; galleryEl.prepend(a); }
    }

    // file input
    fileInput.addEventListener('change', e => { [...e.target.files].forEach(addToQueue); });

    // drag/drop support
    ['dragenter','dragover'].forEach(ev=>{ document.addEventListener(ev, e=>{ e.preventDefault(); }); });
    ['dragleave','drop'].forEach(ev=>{ document.addEventListener(ev, e=>{ e.preventDefault(); }); });
    document.addEventListener('drop', e=>{ if(e.dataTransfer) [...e.dataTransfer.files].forEach(addToQueue); });

    sendBtn.onclick = sendQueue; clearBtn.onclick = clearQueue;
    leaveBtn.onclick = ()=>{ try{ peer?.close(); }catch(e){}; setStatus('나감'); leaveBtn.disabled = true; };

    // speed test: 5MB bench
    speedTestBtn.onclick = async ()=>{
      if(!channel || channel.readyState !== 'open'){ alert('채널 미오픈'); return; }
      const size = 5 * 1024 * 1024;
      const buf = new Uint8Array(size); for(let i=0;i<size;i+=4096) buf[i] = i&255;
      channel.send(JSON.stringify({ t:'file', name:'__bench.bin', size, type:'application/octet-stream', lastModified:Date.now(), hash:'' }));
      const start = performance.now();
      for(let off=0; off<buf.length; off += MAX_CHUNK){
        const chunk = buf.subarray(off, Math.min(off + MAX_CHUNK, buf.length));
        if(channel.bufferedAmount > channel.bufferedAmountLowThreshold){
          await new Promise(res=>{
            const onLow = ()=>{ channel.removeEventListener('bufferedamountlow', onLow); res(); };
            channel.addEventListener('bufferedamountlow', onLow, { once:true });
          });
        }
        channel.send(chunk);
      }
      channel.send(JSON.stringify({ t:'eof' }));
      // wait bench ack
      await new Promise(resolve=>{
        const onMsg = (ev) => { if(typeof ev.data === 'string') { try{ const m = JSON.parse(ev.data); if(m.t === 'ack'){ channel.removeEventListener('message', onMsg); resolve(); } }catch(e){} } };
        channel.addEventListener('message', onMsg);
      });
      const dt = (performance.now() - start)/1000;
      alert(`대략 ${(5/dt).toFixed(2)} MB/s (elapsed ${dt.toFixed(2)}s)`);
    };

    // finally init signaling
    if(window.io) initSocket();
    else setStatus('Socket.IO 로더 실패 — 콘솔 확인');

    // expose some helper on window for debugging
    window._pb = { peer: ()=>peer, channel: ()=>channel, myName };
  })();
  </script>
</body>
</html>
